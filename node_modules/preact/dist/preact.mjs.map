{"version":3,"file":"preact.mjs","sources":["../src/constants.js","../src/options.js","../src/diff/catch-error.js","../src/create-element.js","../src/diff/refs.js","../src/diff/props.js","../src/diff/component.js","../src/tree.js","../src/diff/mount.js","../src/create-context.js","../src/diff/unmount.js","../src/diff/children.js","../src/diff/patch.js","../src/component.js","../src/diff/commit.js","../src/create-root.js","../src/render.js","../src/clone-element.js","../src/create-portal.js"],"sourcesContent":["// Internal.flags bitfield constants\nexport const TYPE_TEXT = 1 << 0;\nexport const TYPE_ELEMENT = 1 << 1;\nexport const TYPE_CLASS = 1 << 2;\nexport const TYPE_FUNCTION = 1 << 3;\n/** Signals this internal has a _parentDom prop that should change the parent\n * DOM node of it's children */\nexport const TYPE_ROOT = 1 << 4;\n\n/** Any type of internal representing DOM */\nexport const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;\n/** Any type of component */\nexport const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;\n\n// Modes of rendering\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Top level render unspecified behaviour (old replaceNode parameter to render) */\nexport const MODE_MUTATIVE_HYDRATE = 1 << 6;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Signifies this VNode errored on the previous render */\nexport const MODE_ERRORED = 1 << 8;\n/** Signifies an error has been thrown and this component will be attempting to\n * handle & rerender the error on next render. In other words, on the next\n * render of this component, unset this mode and set the MODE_RERENDERING_ERROR.\n * This flag is distinct from MODE_RERENDERING_ERROR so that a component can\n * catch multiple errors thrown by its children in one render pass (see test\n * \"should handle double child throws\").\n */\nexport const MODE_PENDING_ERROR = 1 << 9;\n/** Signifies this Internal is attempting to \"handle\" an error and is\n * rerendering. This mode tracks that a component's last rerender was trying to\n * handle an error. As such, if another error is thrown while a component has\n * this flag set, it should not handle the newly thrown error since it failed to\n * successfully rerender the original error. This prevents error handling\n * infinite render loops */\nexport const MODE_RERENDERING_ERROR = 1 << 10;\n/** Signals this internal has been unmounted */\nexport const MODE_UNMOUNTING = 1 << 11;\n/** This Internal is rendered in an SVG tree */\nexport const MODE_SVG = 1 << 12;\n\n/** Signifies that bailout checks will be bypassed */\nexport const FORCE_UPDATE = 1 << 13;\n/** Signifies that a node needs to be updated */\nexport const DIRTY_BIT = 1 << 14;\n/** Signals the component can skip children due to a non-update */\nexport const SKIP_CHILDREN = 1 << 15;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(\n\tMODE_HYDRATE |\n\tMODE_MUTATIVE_HYDRATE |\n\tMODE_SUSPENDED |\n\tMODE_ERRORED |\n\tMODE_RERENDERING_ERROR |\n\tFORCE_UPDATE |\n\tSKIP_CHILDREN\n);\n\n/** Modes a child internal inherits from their parent */\nexport const INHERITED_MODES = MODE_HYDRATE | MODE_MUTATIVE_HYDRATE | MODE_SVG;\n\nexport const EMPTY_ARR = [];\nexport const UNDEFINED = undefined;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError,\n};\n\nexport default options;\n","import {\n\tDIRTY_BIT,\n\tMODE_RERENDERING_ERROR,\n\tMODE_PENDING_ERROR,\n\tTYPE_COMPONENT\n} from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').Internal} internal The Internal node that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, internal) {\n\twhile ((internal = internal._parent)) {\n\t\tif (\n\t\t\tinternal.flags & TYPE_COMPONENT &&\n\t\t\t~internal.flags & MODE_RERENDERING_ERROR\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (internal.type.getDerivedStateFromError) {\n\t\t\t\t\tinternal._component.setState(\n\t\t\t\t\t\tinternal.type.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (internal._component.componentDidCatch) {\n\t\t\t\t\tinternal._component.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\t// NOTE: We're checking that any component in the stack got marked as dirty, even if it did so prior to this loop,\n\t\t\t\t// which is technically incorrect. However, there is no way for a component to mark itself as dirty during rendering.\n\t\t\t\t// The only way for a component to falsely intercept error bubbling would be to manually sets its internal dirty flag.\n\t\t\t\tif (internal.flags & DIRTY_BIT) {\n\t\t\t\t\tinternal.flags |= MODE_PENDING_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { UNDEFINED } from './constants';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\n\tif (children !== undefined) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, 0);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tconstructor: undefined,\n\t\t_vnodeId: original || ++vnodeId\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\n/**\n * @param {import('./internal').ComponentChildren} childVNode\n * @returns {import('./internal').VNode | string | null}\n */\nexport function normalizeToVNode(childVNode) {\n\tlet type = typeof childVNode;\n\tif (childVNode == null || type === 'boolean') {\n\t\treturn null;\n\t}\n\tif (type === 'object') {\n\t\tif (Array.isArray(childVNode)) {\n\t\t\treturn createVNode(Fragment, { children: childVNode }, null, null, 0);\n\t\t}\n\t} else if (type !== 'string' && type !== 'function') {\n\t\treturn String(childVNode);\n\t}\n\treturn childVNode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === UNDEFINED;\n","import options from '../options';\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').Internal} internal\n */\nexport function applyRef(ref, value, internal) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse if (ref) ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, internal);\n\t}\n}\n","import options from '../options';\n\nfunction setStyle(dom, key, value) {\n\tif (key[0] === '-') {\n\t\tdom.style.setProperty(key, value);\n\t} else {\n\t\tdom.style[key] = value == null ? '' : value;\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {number} isSvg 0 if not an SVG element, else it is an SVG element\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tsetStyle(dom, 'cssText', value);\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tsetStyle(dom, 'cssText', (oldValue = ''));\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!value || !(name in value)) {\n\t\t\t\t\t\tsetStyle(dom, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (name in value) {\n\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\tsetStyle(dom, name, value[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (\n\t\t\tvalue != null &&\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\n\t\t) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n\tif (this._isControlled) {\n\t\tif (this.value != null && (e.type === 'input' || e.type === 'change')) {\n\t\t\tthis.value = this._prevValue;\n\t\t}\n\t\tif (this.checked != null && e.type === 'change') {\n\t\t\tthis.checked = this._prevValue;\n\t\t}\n\t}\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import options from '../options';\nimport { DIRTY_BIT, FORCE_UPDATE, SKIP_CHILDREN } from '../constants';\nimport { rendererState } from '../component';\n\n/**\n * Render a function component\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @returns {import('../internal').ComponentChildren} the component's children\n */\nexport function renderFunctionComponent(\n\tinternal,\n\tnewVNode,\n\tcomponentContext\n) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\n\tlet type = /** @type {import('../internal').ComponentType} */ (internal.type);\n\n\t// @TODO split update + mount?\n\tlet newProps = newVNode ? newVNode.props : internal.props;\n\n\tif (!(c = internal._component)) {\n\t\tinternal._component = c = {\n\t\t\tprops: newProps,\n\t\t\tcontext: componentContext,\n\t\t\tforceUpdate: internal.rerender.bind(null, internal)\n\t\t};\n\t\tc._internal = internal;\n\t\tinternal.flags |= DIRTY_BIT;\n\t}\n\n\tif (newVNode && newVNode._vnodeId === internal._vnodeId) {\n\t\tc.props = newProps;\n\t\tinternal.flags |= SKIP_CHILDREN;\n\t\treturn;\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\n\tlet renderResult;\n\tlet renderHook = options._render;\n\tlet counter = 0;\n\twhile (counter++ < 25) {\n\t\tinternal.flags &= ~DIRTY_BIT;\n\t\tif (renderHook) renderHook(internal);\n\t\trenderResult = type.call(c, c.props, componentContext);\n\t\tif (!(internal.flags & DIRTY_BIT)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinternal.flags &= ~DIRTY_BIT;\n\tif (c.getChildContext != null) {\n\t\trendererState._context = internal._context = Object.assign(\n\t\t\t{},\n\t\t\trendererState._context,\n\t\t\tc.getChildContext()\n\t\t);\n\t}\n\n\treturn renderResult;\n}\n\n/**\n * Render a class component\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @returns {import('../internal').ComponentChildren} the component's children\n */\nexport function renderClassComponent(\n\tinternal,\n\tnewVNode,\n\tcomponentContext\n) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\tlet isNew, oldProps, oldState, snapshot;\n\n\tlet type = /** @type {import('../internal').ComponentType} */ (internal.type);\n\n\t// @TODO split update + mount?\n\tlet newProps = newVNode ? newVNode.props : internal.props;\n\n\tif (!(c = internal._component)) {\n\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\tinternal._component = c = new type(newProps, componentContext); // eslint-disable-line new-cap\n\n\t\tif (!c.state) c.state = {};\n\t\tisNew = true;\n\t\tc._internal = internal;\n\t\tinternal.flags |= DIRTY_BIT;\n\t}\n\n\t// Invoke getDerivedStateFromProps\n\tif (c._nextState == null) {\n\t\tc._nextState = c.state;\n\t}\n\tif (type.getDerivedStateFromProps != null) {\n\t\tif (c._nextState == c.state) {\n\t\t\tc._nextState = Object.assign({}, c._nextState);\n\t\t}\n\n\t\tObject.assign(\n\t\t\tc._nextState,\n\t\t\ttype.getDerivedStateFromProps(newProps, c._nextState)\n\t\t);\n\t}\n\n\toldProps = c.props;\n\toldState = c.state;\n\tif (isNew) {\n\t\tif (type.getDerivedStateFromProps == null && c.componentWillMount != null) {\n\t\t\tc.componentWillMount();\n\t\t}\n\n\t\tif (c.componentDidMount != null) {\n\t\t\t// If the component was constructed, queue up componentDidMount so the\n\t\t\t// first time this internal commits (regardless of suspense or not) it\n\t\t\t// will be called\n\t\t\tinternal._commitCallbacks.push(c.componentDidMount.bind(c));\n\t\t}\n\t} else {\n\t\tif (\n\t\t\ttype.getDerivedStateFromProps == null &&\n\t\t\tnewProps !== oldProps &&\n\t\t\tc.componentWillReceiveProps != null\n\t\t) {\n\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t}\n\n\t\tif (\n\t\t\t(!(internal.flags & FORCE_UPDATE) &&\n\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\tc.shouldComponentUpdate(newProps, c._nextState, componentContext) ===\n\t\t\t\t\tfalse) ||\n\t\t\t(newVNode && newVNode._vnodeId === internal._vnodeId)\n\t\t) {\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\t\t\tinternal.flags |= SKIP_CHILDREN;\n\t\t\treturn;\n\t\t}\n\n\t\tif (c.componentWillUpdate != null) {\n\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t}\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\tc.state = c._nextState;\n\n\tlet renderHook = options._render;\n\tif (renderHook) renderHook(internal);\n\n\tinternal.flags &= ~DIRTY_BIT;\n\n\tlet renderResult = c.render(c.props, c.state, c.context);\n\n\t// Handle setState called in render, see #2553\n\tc.state = c._nextState;\n\n\tif (c.getChildContext != null) {\n\t\trendererState._context = internal._context = Object.assign(\n\t\t\t{},\n\t\t\trendererState._context,\n\t\t\tc.getChildContext()\n\t\t);\n\t}\n\n\tif (!isNew) {\n\t\tif (c.getSnapshotBeforeUpdate != null) {\n\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t}\n\n\t\t// Only schedule componentDidUpdate if the component successfully rendered\n\t\tif (c.componentDidUpdate != null) {\n\t\t\tinternal._commitCallbacks.push(() => {\n\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t});\n\t\t}\n\t}\n\n\treturn renderResult;\n}\n","import options from './options';\nimport {\n\tTYPE_FUNCTION,\n\tTYPE_ELEMENT,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tTYPE_ROOT,\n\tINHERITED_MODES,\n\tTYPE_COMPONENT,\n\tTYPE_DOM,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { enqueueRender } from './component';\n\n/**\n * Create an internal tree node\n * @param {import('./internal').VNode | string} vnode\n * @param {import('./internal').Internal} [parentInternal]\n * @returns {import('./internal').Internal}\n */\nexport function createInternal(vnode, parentInternal) {\n\tlet type = null,\n\t\tprops,\n\t\tkey,\n\t\tref;\n\n\t/** @type {number} */\n\tlet flags = parentInternal ? parentInternal.flags & INHERITED_MODES : 0;\n\n\t// Text VNodes/Internals have an ID of 0 that is never used:\n\tlet vnodeId = 0;\n\n\tif (typeof vnode === 'string') {\n\t\t// type = null;\n\t\tflags |= TYPE_TEXT;\n\t\tprops = vnode;\n\t}\n\t// Prevent JSON injection by rendering injected objects as empty Text nodes\n\telse if (vnode.constructor !== UNDEFINED) {\n\t\tflags |= TYPE_TEXT;\n\t\tprops = '';\n\t} else {\n\t\ttype = vnode.type;\n\t\tprops = vnode.props;\n\t\tkey = vnode.key;\n\t\tref = vnode.ref;\n\t\tvnodeId = vnode._vnodeId;\n\n\t\t// @TODO re-enable this when we stop removing key+ref from VNode props\n\t\t// if (props) {\n\t\t// \tif ((key = props.key) != null) {\n\t\t// \t\tprops.key = UNDEFINED;\n\t\t// \t}\n\t\t// \tif (typeof type !== 'function' && (ref = props.ref) != null) {\n\t\t// \t\tprops.ref = UNDEFINED;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tprops = {};\n\t\t// }\n\n\t\t// flags = typeof type === 'function' ? COMPONENT_NODE : ELEMENT_NODE;\n\t\tflags |=\n\t\t\ttypeof type === 'function'\n\t\t\t\t? type.prototype && type.prototype.render\n\t\t\t\t\t? TYPE_CLASS\n\t\t\t\t\t: props._parentDom\n\t\t\t\t\t? TYPE_ROOT\n\t\t\t\t\t: TYPE_FUNCTION\n\t\t\t\t: TYPE_ELEMENT;\n\n\t\tif (flags & TYPE_ELEMENT && type === 'svg') {\n\t\t\tflags |= MODE_SVG;\n\t\t} else if (\n\t\t\tparentInternal &&\n\t\t\tparentInternal.flags & MODE_SVG &&\n\t\t\tparentInternal.type === 'foreignObject'\n\t\t) {\n\t\t\tflags &= ~MODE_SVG;\n\t\t}\n\t}\n\n\t/** @type {import('./internal').Internal} */\n\tconst internal = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_prevRef: null,\n\t\tdata: flags & TYPE_COMPONENT ? {} : null,\n\t\t_commitCallbacks: flags & TYPE_COMPONENT ? [] : null,\n\t\trerender: enqueueRender,\n\t\tflags,\n\t\t_children: null,\n\t\t_parent: parentInternal,\n\t\t_vnodeId: vnodeId,\n\t\t_dom: null,\n\t\t_component: null,\n\t\t_context: null,\n\t\t_depth: parentInternal ? parentInternal._depth + 1 : 0\n\t};\n\n\tif (options._internal) options._internal(internal, vnode);\n\n\treturn internal;\n}\n\nconst shouldSearchComponent = internal =>\n\tinternal.flags & TYPE_COMPONENT &&\n\t(!(internal.flags & TYPE_ROOT) ||\n\t\tinternal.props._parentDom == getParentDom(internal._parent));\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number | null} [childIndex]\n * @returns {import('./internal').PreactNode}\n */\nexport function getDomSibling(internal, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn getDomSibling(\n\t\t\tinternal._parent,\n\t\t\tinternal._parent._children.indexOf(internal) + 1\n\t\t);\n\t}\n\n\tlet childDom = getChildDom(internal, childIndex);\n\tif (childDom) {\n\t\treturn childDom;\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children. We\n\t// must resume from this vnode's sibling (in it's parent _children array).\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search). Note, the top of the tree has _parent == null so avoiding that\n\t// here.\n\treturn internal._parent && shouldSearchComponent(internal)\n\t\t? getDomSibling(internal)\n\t\t: null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number} [i]\n * @returns {import('./internal').PreactElement}\n */\nexport function getChildDom(internal, i) {\n\tif (internal._children == null) {\n\t\treturn null;\n\t}\n\n\tfor (i = i || 0; i < internal._children.length; i++) {\n\t\tlet child = internal._children[i];\n\t\tif (child != null) {\n\t\t\tif (child.flags & TYPE_DOM) {\n\t\t\t\treturn child._dom;\n\t\t\t}\n\n\t\t\tif (shouldSearchComponent(child)) {\n\t\t\t\tlet childDom = getChildDom(child);\n\t\t\t\tif (childDom) {\n\t\t\t\t\treturn childDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n/**\n * @param {import('./internal').Internal} internal\n * @returns {any}\n */\nexport function getParentContext(internal) {\n\t// @TODO: compare performance of recursion here (it's 11b smaller, but may be slower for deep trees)\n\treturn internal._context || getParentContext(internal._parent);\n\n\t// while ((internal = internal._parent)) {\n\t// \tlet context = internal._context;\n\t// \tif (context != null) return context;\n\t// }\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @returns {import('./internal').PreactElement}\n */\nexport function getParentDom(internal) {\n\tlet parent = internal;\n\n\t// if this is a Root internal, return its parent DOM:\n\tif (parent.flags & TYPE_ROOT) {\n\t\treturn parent.props._parentDom;\n\t}\n\n\t// walk up the tree to find the nearest DOM or Root Internal:\n\twhile ((parent = parent._parent)) {\n\t\tif (parent.flags & TYPE_ROOT) {\n\t\t\treturn parent.props._parentDom;\n\t\t} else if (parent.flags & TYPE_ELEMENT) {\n\t\t\treturn parent._dom;\n\t\t}\n\t}\n}\n","import { applyRef } from './refs';\nimport {\n\tTYPE_COMPONENT,\n\tTYPE_ELEMENT,\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tMODE_SVG\n} from '../constants';\nimport { normalizeToVNode, Fragment } from '../create-element';\nimport { setProperty } from './props';\nimport { renderClassComponent, renderFunctionComponent } from './component';\nimport { createInternal } from '../tree';\nimport options from '../options';\nimport { rendererState } from '../component';\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').PreactNode} startDom\n * @returns {import('../internal').PreactNode | null} pointer to the next DOM node to be hydrated (or null)\n */\nexport function mount(internal, newVNode, startDom) {\n\tif (options._diff) options._diff(internal, newVNode);\n\n\t/** @type {import('../internal').PreactNode} */\n\tlet nextDomSibling;\n\n\ttry {\n\t\tif (internal.flags & TYPE_COMPONENT) {\n\t\t\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t\t\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t\t\t// top.\n\t\t\tlet prevStartDom = startDom;\n\t\t\tlet prevParentDom = rendererState._parentDom;\n\t\t\tif (internal.flags & TYPE_ROOT) {\n\t\t\t\trendererState._parentDom = newVNode.props._parentDom;\n\n\t\t\t\t// Note: this is likely always true because we are inside mount()\n\t\t\t\tif (rendererState._parentDom !== prevParentDom) {\n\t\t\t\t\tstartDom = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet prevContext = rendererState._context;\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\tlet tmp = newVNode.type.contextType;\n\t\t\tlet provider = tmp && rendererState._context[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: rendererState._context;\n\n\t\t\tif (provider) provider._subs.add(internal);\n\n\t\t\tlet renderResult;\n\n\t\t\tif (internal.flags & TYPE_CLASS) {\n\t\t\t\trenderResult = renderClassComponent(\n\t\t\t\t\tinternal,\n\t\t\t\t\tnull,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\trenderResult = renderFunctionComponent(\n\t\t\t\t\tinternal,\n\t\t\t\t\tnull,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (renderResult == null) {\n\t\t\t\tnextDomSibling = startDom;\n\t\t\t} else {\n\t\t\t\tif (typeof renderResult === 'object') {\n\t\t\t\t\t// dissolve unkeyed root fragments:\n\t\t\t\t\tif (renderResult.type === Fragment && renderResult.key == null) {\n\t\t\t\t\t\trenderResult = renderResult.props.children;\n\t\t\t\t\t}\n\t\t\t\t\tif (!Array.isArray(renderResult)) {\n\t\t\t\t\t\trenderResult = [renderResult];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trenderResult = [renderResult];\n\t\t\t\t}\n\n\t\t\t\tnextDomSibling = mountChildren(\n\t\t\t\t\tinternal,\n\t\t\t\t\trenderResult,\n\t\t\t\t\tstartDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tinternal._commitCallbacks != null &&\n\t\t\t\tinternal._commitCallbacks.length\n\t\t\t) {\n\t\t\t\trendererState._commitQueue.push(internal);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tinternal.flags & TYPE_ROOT &&\n\t\t\t\tprevParentDom !== rendererState._parentDom\n\t\t\t) {\n\t\t\t\t// If we just mounted a root node/Portal, and it changed the parentDom\n\t\t\t\t// of it's children, then we need to resume the diff from it's previous\n\t\t\t\t// startDom element, which could be null if we are mounting an entirely\n\t\t\t\t// new tree, or the portal's nextSibling if we are mounting a Portal in\n\t\t\t\t// an existing tree.\n\t\t\t\tnextDomSibling = prevStartDom;\n\t\t\t}\n\n\t\t\trendererState._parentDom = prevParentDom;\n\t\t\t// In the event this subtree creates a new context for its children, restore\n\t\t\t// the previous context for its siblings\n\t\t\trendererState._context = prevContext;\n\t\t} else {\n\t\t\t// @TODO: we could just assign this as internal.dom here\n\t\t\tlet hydrateDom =\n\t\t\t\tinternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)\n\t\t\t\t\t? startDom\n\t\t\t\t\t: null;\n\n\t\t\tnextDomSibling = mountElement(internal, hydrateDom);\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal.flags &= RESET_MODE;\n\t} catch (e) {\n\t\tinternal._vnodeId = 0;\n\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\n\t\tif (internal.flags & MODE_HYDRATE) {\n\t\t\t// @ts-ignore Trust me TS, nextSibling is a PreactElement\n\t\t\tnextDomSibling = startDom && startDom.nextSibling;\n\t\t\tinternal._dom = startDom; // Save our current DOM position to resume later\n\t\t}\n\t\toptions._catchError(e, internal);\n\t}\n\n\treturn nextDomSibling;\n}\n\n/**\n * Construct (or select, if hydrating) a new DOM element for the given Internal.\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').PreactNode} dom A DOM node to attempt to re-use during hydration\n * @returns {import('../internal').PreactNode}\n */\nfunction mountElement(internal, dom) {\n\tlet newProps = internal.props;\n\tlet nodeType = internal.type;\n\tlet flags = internal.flags;\n\n\t// Are we rendering within an inline SVG?\n\tlet isSvg = flags & MODE_SVG;\n\n\t// Are we *not* hydrating? (a top-level render() or mutative hydration):\n\tlet isFullRender = ~flags & MODE_HYDRATE;\n\n\t/** @type {any} */\n\tlet i, value;\n\n\t// if hydrating (hydrate() or render() with replaceNode), find the matching child:\n\tif (flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)) {\n\t\twhile (\n\t\t\tdom &&\n\t\t\t(nodeType ? dom.localName !== nodeType : dom.nodeType !== 3)\n\t\t) {\n\t\t\tdom = dom.nextSibling;\n\t\t}\n\t}\n\n\tlet isNew = dom == null;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (isNew) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\tdom = document.createTextNode(newProps);\n\t\t} else if (dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\n\t\tinternal._dom = dom;\n\t} else {\n\t\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\t\t// if (nodeType === 'svg') internal.flags |= MODE_SVG;\n\n\t\tif (isNew) {\n\t\t\tif (isSvg) {\n\t\t\t\tdom = document.createElementNS(\n\t\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom = document.createElement(\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType,\n\t\t\t\t\tnewProps.is && newProps\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\t\tinternal.flags = flags &= RESET_MODE;\n\t\t\tisFullRender = 1;\n\t\t}\n\n\t\t// @TODO: Consider removing and instructing users to instead set the desired\n\t\t// prop for removal to undefined/null. During hydration, props are not\n\t\t// diffed at all (including dangerouslySetInnerHTML)\n\t\tif (flags & MODE_MUTATIVE_HYDRATE) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i].name;\n\t\t\t\tif (!(value in newProps)) {\n\t\t\t\t\tdom.removeAttribute(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet newHtml, newValue, newChildren;\n\t\tif (\n\t\t\t(nodeType === 'input' ||\n\t\t\t\tnodeType === 'textarea' ||\n\t\t\t\tnodeType === 'select') &&\n\t\t\t(newProps.onInput || newProps.onChange)\n\t\t) {\n\t\t\tif (newProps.value != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.value;\n\t\t\t} else if (newProps.checked != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.checked;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i === 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i === 'value') {\n\t\t\t\tnewValue = value;\n\t\t\t} else if (\n\t\t\t\tvalue != null &&\n\t\t\t\t(isFullRender || typeof value === 'function')\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, null, isSvg);\n\t\t\t}\n\t\t}\n\n\t\tinternal._dom = dom;\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tif (isFullRender && newHtml.__html) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\t\t} else if (newChildren != null) {\n\t\t\tconst prevParentDom = rendererState._parentDom;\n\t\t\trendererState._parentDom = dom;\n\t\t\tmountChildren(\n\t\t\t\tinternal,\n\t\t\t\tArray.isArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tisNew ? null : dom.firstChild\n\t\t\t);\n\t\t\trendererState._parentDom = prevParentDom;\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (isFullRender && newValue != null) {\n\t\t\tsetProperty(dom, 'value', newValue, null, 0);\n\t\t}\n\t}\n\n\t// @ts-ignore\n\treturn isNew ? null : dom.nextSibling;\n}\n\n/**\n * Mount all children of an Internal\n * @param {import('../internal').Internal} internal The parent Internal of the given children\n * @param {import('../internal').ComponentChild[]} children\n * @param {import('../internal').PreactNode} startDom\n */\nexport function mountChildren(\n\tinternal,\n\tchildren,\n\tstartDom\n) {\n\tlet internalChildren = (internal._children = []),\n\t\ti,\n\t\tchildVNode,\n\t\tchildInternal,\n\t\tnewDom,\n\t\tmountedNextChild;\n\n\tfor (i = 0; i < children.length; i++) {\n\t\tchildVNode = normalizeToVNode(children[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tinternalChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildInternal = createInternal(childVNode, internal);\n\t\tinternalChildren[i] = childInternal;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tmountedNextChild = mount(\n\t\t\tchildInternal,\n\t\t\tchildVNode,\n\t\t\tstartDom\n\t\t);\n\n\t\tnewDom = childInternal._dom;\n\n\t\tif (childInternal.flags & TYPE_COMPONENT || newDom == startDom) {\n\t\t\t// If the child is a Fragment-like or if it is DOM VNode and its _dom\n\t\t\t// property matches the dom we are diffing (i.e. startDom), just\n\t\t\t// continue with the mountedNextChild\n\t\t\tstartDom = mountedNextChild;\n\t\t} else if (newDom != null) {\n\t\t\t// The DOM the diff should begin with is now startDom (since we inserted\n\t\t\t// newDom before startDom) so ignore mountedNextChild and continue with\n\t\t\t// startDom\n\t\t\trendererState._parentDom.insertBefore(newDom, startDom);\n\t\t}\n\n\t\tif (childInternal.ref) {\n\t\t\tapplyRef(\n\t\t\t\tchildInternal.ref,\n\t\t\t\tchildInternal._component || newDom,\n\t\t\t\tchildInternal\n\t\t\t);\n\t\t}\n\t}\n\n\t// Remove children that are not part of any vnode.\n\tif (\n\t\tinternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE) &&\n\t\tinternal.flags & TYPE_ELEMENT\n\t) {\n\t\t// TODO: Would it be simpler to just clear the pre-existing DOM in top-level\n\t\t// render if render is called with no oldVNode & existing children & no\n\t\t// replaceNode? Instead of patching the DOM to match the VNode tree? (remove\n\t\t// attributes & unused DOM)\n\t\twhile (startDom) {\n\t\t\ti = startDom;\n\t\t\tstartDom = startDom.nextSibling;\n\t\t\ti.remove();\n\t\t}\n\t}\n\n\treturn startDom;\n}\n","import { enqueueRender } from './component';\n\nlet nextContextId = 0;\n\nconst providers = new Set();\n\nexport const unsubscribeFromContext = internal => {\n\t// if this was a context provider, delete() returns true and we exit:\n\tif (providers.delete(internal)) return;\n\t// ... otherwise, unsubscribe from any contexts:\n\tproviders.forEach(p => {\n\t\tp._component._subs.delete(internal);\n\t});\n};\n\nexport const createContext = (defaultValue, contextId) => {\n\tcontextId = '__cC' + nextContextId++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props, ctx) {\n\t\t\t// initial setup:\n\t\t\tif (!this._subs) {\n\t\t\t\tthis._subs = new Set();\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\t\t\t\tthis.getChildContext = () => ctx;\n\t\t\t\tproviders.add(this._internal);\n\t\t\t}\n\t\t\t// re-render subscribers in response to value change\n\t\t\telse if (props.value !== this._prev) {\n\t\t\t\tthis._subs.forEach(enqueueRender);\n\t\t\t}\n\t\t\tthis._prev = props.value;\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n};\n","import { MODE_UNMOUNTING, TYPE_DOM, TYPE_ROOT } from '../constants';\nimport { unsubscribeFromContext } from '../create-context';\nimport options from '../options';\nimport { applyRef } from './refs';\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').Internal} internal The virtual node to unmount\n * @param {import('../internal').Internal} parentInternal The parent of the VNode that\n * initiated the unmount\n * @param {number} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(internal, parentInternal, skipRemove) {\n\tlet r,\n\t\ti = 0;\n\tif (options.unmount) options.unmount(internal);\n\tinternal.flags |= MODE_UNMOUNTING;\n\n\tif ((r = internal.ref)) {\n\t\tapplyRef(r, null, parentInternal);\n\t}\n\n\tif ((r = internal._component)) {\n\t\tunsubscribeFromContext(internal);\n\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentInternal);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((r = internal._children)) {\n\t\tfor (; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentInternal,\n\t\t\t\t\tskipRemove ? ~internal.flags & TYPE_ROOT : internal.flags & TYPE_DOM\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && internal.flags & TYPE_DOM) {\n\t\tinternal._dom.remove();\n\t}\n\n\tinternal._dom = null;\n}\n","import { applyRef } from './refs';\nimport { normalizeToVNode } from '../create-element';\nimport {\n\tTYPE_COMPONENT,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tEMPTY_ARR,\n\tTYPE_DOM,\n\tUNDEFINED\n} from '../constants';\nimport { mount } from './mount';\nimport { patch } from './patch';\nimport { unmount } from './unmount';\nimport { createInternal, getDomSibling } from '../tree';\nimport { rendererState } from '../component';\n\n/**\n * Update an internal with new children.\n * @param {import('../internal').Internal} internal The internal whose children should be patched\n * @param {import('../internal').ComponentChild[]} children The new children, represented as VNodes\n */\nexport function patchChildren(internal, children) {\n\tlet oldChildren =\n\t\t(internal._children && internal._children.slice()) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\tlet remainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\tlet i;\n\n\t/** @type {import('../internal').Internal} */\n\tlet childInternal;\n\n\t/** @type {import('../internal').ComponentChild} */\n\tlet childVNode;\n\n\t/** @type {import('../internal').Internal[]} */\n\tconst newChildren = [];\n\n\tfor (i = 0; i < children.length; i++) {\n\t\tchildVNode = normalizeToVNode(children[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tnewChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet skewedIndex = i + skew;\n\n\t\t/// TODO: Reconsider if we should bring back the \"not moving text nodes\" logic?\n\t\tlet matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\tif (matchingIndex === -1) {\n\t\t\tchildInternal = UNDEFINED;\n\t\t} else {\n\t\t\tchildInternal = oldChildren[matchingIndex];\n\t\t\toldChildren[matchingIndex] = UNDEFINED;\n\t\t\tremainingOldChildren--;\n\t\t}\n\n\t\tlet mountingChild = childInternal == null;\n\n\t\tif (mountingChild) {\n\t\t\tchildInternal = createInternal(childVNode, internal);\n\n\t\t\t// We are mounting a new VNode\n\t\t\tmount(\n\t\t\t\tchildInternal,\n\t\t\t\tchildVNode,\n\t\t\t\tgetDomSibling(internal, skewedIndex)\n\t\t\t);\n\t\t}\n\t\t// If this node suspended during hydration, and no other flags are set:\n\t\t// @TODO: might be better to explicitly check for MODE_ERRORED here.\n\t\telse if (\n\t\t\t(childInternal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t) {\n\t\t\t// We are resuming the hydration of a VNode\n\t\t\tmount(\n\t\t\t\tchildInternal,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal._dom\n\t\t\t);\n\t\t} else {\n\t\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\t\tpatch(childInternal, childVNode);\n\t\t}\n\n\t\tgo: if (mountingChild) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// Perform insert of new dom\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\trendererState._parentDom.insertBefore(\n\t\t\t\t\tchildInternal._dom,\n\t\t\t\t\tgetDomSibling(internal, skewedIndex)\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\t// Move this DOM into its correct place\n\t\t\tif (matchingIndex === skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t\tbreak go;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\tif (remainingOldChildren > children.length - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t\tbreak go;\n\t\t\t\t} else {\n\t\t\t\t\t// ### Change from keyed: I think this was missing from the algo...\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\tskew = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskew = 0;\n\t\t\t}\n\n\t\t\tskewedIndex = i + skew;\n\n\t\t\tif (matchingIndex == i) break go;\n\n\t\t\tlet nextSibling = getDomSibling(internal, skewedIndex + 1);\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\trendererState._parentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t} else {\n\t\t\t\tinsertComponentDom(\n\t\t\t\t\tchildInternal,\n\t\t\t\t\tnextSibling,\n\t\t\t\t\trendererState._parentDom\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tnewChildren[i] = childInternal;\n\t}\n\n\tinternal._children = newChildren;\n\n\t// Remove remaining oldChildren if there are any.\n\tif (remainingOldChildren > 0) {\n\t\tfor (i = oldChildrenLength; i--; ) {\n\t\t\tif (oldChildren[i] != null) {\n\t\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tfor (i = 0; i < newChildren.length; i++) {\n\t\tchildInternal = newChildren[i];\n\t\tif (childInternal) {\n\t\t\tlet oldRef = childInternal._prevRef;\n\t\t\tif (childInternal.ref != oldRef) {\n\t\t\t\tif (oldRef) applyRef(oldRef, null, childInternal);\n\t\t\t\tif (childInternal.ref)\n\t\t\t\t\tapplyRef(\n\t\t\t\t\t\tchildInternal.ref,\n\t\t\t\t\t\tchildInternal._component || childInternal._dom,\n\t\t\t\t\t\tchildInternal\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('../internal').VNode | string} childVNode\n * @param {import('../internal').Internal[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst type = typeof childVNode === 'string' ? null : childVNode.type;\n\tconst key = type !== null ? childVNode.key : UNDEFINED;\n\tlet match = -1;\n\tlet x = skewedIndex - 1; // i - 1;\n\tlet y = skewedIndex + 1; // i + 1;\n\tlet oldChild = oldChildren[skewedIndex]; // i\n\n\tif (\n\t\t// ### Change from keyed: support for matching null placeholders\n\t\toldChild === null ||\n\t\t(oldChild != null && oldChild.type === type && oldChild.key == key)\n\t) {\n\t\tmatch = skewedIndex; // i\n\t}\n\t// If there are any unused children left (ignoring an available in-place child which we just checked)\n\telse if (remainingOldChildren > (oldChild != null ? 1 : 0)) {\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldChild = oldChildren[x];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldChild = oldChildren[y];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t} else if (x < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').PreactNode} nextSibling\n * @param {import('../internal').PreactNode} parentDom\n */\nexport function insertComponentDom(internal, nextSibling, parentDom) {\n\tif (internal._children == null) {\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < internal._children.length; i++) {\n\t\tlet childInternal = internal._children[i];\n\t\tif (childInternal) {\n\t\t\tchildInternal._parent = internal;\n\n\t\t\tif (childInternal.flags & TYPE_COMPONENT) {\n\t\t\t\tinsertComponentDom(childInternal, nextSibling, parentDom);\n\t\t\t} else if (childInternal._dom != nextSibling) {\n\t\t\t\tparentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tfor (children of children) {\n\t\t\ttoChildArray(children, out);\n\t\t}\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n","import { patchChildren, insertComponentDom } from './children';\nimport { setProperty } from './props';\nimport options from '../options';\nimport { renderClassComponent, renderFunctionComponent } from './component';\nimport {\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_ELEMENT,\n\tMODE_SUSPENDED,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tTYPE_CLASS,\n\tMODE_SVG,\n\tUNDEFINED,\n\tMODE_HYDRATE,\n\tMODE_PENDING_ERROR,\n\tMODE_RERENDERING_ERROR,\n\tSKIP_CHILDREN,\n\tDIRTY_BIT\n} from '../constants';\nimport { getDomSibling } from '../tree';\nimport { mountChildren } from './mount';\nimport { Fragment } from '../create-element';\nimport { rendererState } from '../component';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {import('../internal').VNode | string} vnode The new virtual node\n */\nexport function patch(internal, vnode) {\n\tlet flags = internal.flags;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (vnode !== internal.props) {\n\t\t\t// @ts-ignore We know that newVNode is string/number/bigint, and internal._dom is Text\n\t\t\tinternal._dom.data = vnode;\n\t\t\tinternal.props = vnode;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (vnode.constructor !== UNDEFINED) return;\n\n\tif (options._diff) options._diff(internal, vnode);\n\n\t// Root nodes render their children into a specific parent DOM element.\n\t// They can occur anywhere in the tree, can be nested, and currently allow reparenting during patches.\n\t// @TODO: Decide if we actually want to support silent reparenting during patch - is it worth the bytes?\n\tlet prevParentDom = rendererState._parentDom;\n\tif (flags & TYPE_ROOT) {\n\t\trendererState._parentDom = vnode.props._parentDom;\n\n\t\tif (internal.props._parentDom !== vnode.props._parentDom) {\n\t\t\tlet nextSibling =\n\t\t\t\trendererState._parentDom == prevParentDom\n\t\t\t\t\t? getDomSibling(internal)\n\t\t\t\t\t: null;\n\t\t\tinsertComponentDom(internal, nextSibling, rendererState._parentDom);\n\t\t}\n\t}\n\n\tif (flags & TYPE_ELEMENT) {\n\t\tif (vnode._vnodeId !== internal._vnodeId) {\n\t\t\t// @ts-ignore dom is a PreactElement here\n\t\t\tpatchElement(internal, vnode);\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tif (internal.flags & MODE_PENDING_ERROR) {\n\t\t\t\t// Toggle the MODE_PENDING_ERROR and MODE_RERENDERING_ERROR flags. In\n\t\t\t\t// actuality, this should turn off the MODE_PENDING_ERROR flag and turn on\n\t\t\t\t// the MODE_RERENDERING_ERROR flag.\n\t\t\t\tinternal.flags ^= MODE_PENDING_ERROR | MODE_RERENDERING_ERROR;\n\t\t\t}\n\n\t\t\tlet prevContext = rendererState._context;\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\tlet tmp = vnode.type.contextType;\n\t\t\tlet provider = tmp && rendererState._context[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: rendererState._context;\n\t\t\tlet isNew = !internal || !internal._component;\n\n\t\t\tlet renderResult;\n\n\t\t\tif (internal.flags & TYPE_CLASS) {\n\t\t\t\trenderResult = renderClassComponent(\n\t\t\t\t\tinternal,\n\t\t\t\t\tvnode,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\trenderResult = renderFunctionComponent(\n\t\t\t\t\tinternal,\n\t\t\t\t\tvnode,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (renderResult == null) {\n\t\t\t\trenderResult = [];\n\t\t\t} else if (typeof renderResult === 'object') {\n\t\t\t\tif (renderResult.type === Fragment && renderResult.key == null) {\n\t\t\t\t\trenderResult = renderResult.props.children;\n\t\t\t\t}\n\t\t\t\tif (!Array.isArray(renderResult)) {\n\t\t\t\t\trenderResult = [renderResult];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trenderResult = [renderResult];\n\t\t\t}\n\n\t\t\tif (internal.flags & SKIP_CHILDREN) {\n\t\t\t\tinternal.props = vnode.props;\n\t\t\t\tinternal.flags &= ~SKIP_CHILDREN;\n\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\tif (vnode && vnode._vnodeId !== internal._vnodeId) {\n\t\t\t\t\tinternal.flags &= ~DIRTY_BIT;\n\t\t\t\t}\n\t\t\t} else if (internal._children == null) {\n\t\t\t\tlet siblingDom =\n\t\t\t\t\t(internal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t\t\t\t\t? internal._dom\n\t\t\t\t\t\t: isNew || internal.flags & MODE_HYDRATE\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: getDomSibling(internal);\n\n\t\t\t\tmountChildren(\n\t\t\t\t\tinternal,\n\t\t\t\t\trenderResult,\n\t\t\t\t\tsiblingDom\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpatchChildren(internal, renderResult);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tinternal._commitCallbacks != null &&\n\t\t\t\tinternal._commitCallbacks.length\n\t\t\t) {\n\t\t\t\trendererState._commitQueue.push(internal);\n\t\t\t}\n\n\t\t\trendererState._parentDom = prevParentDom;\n\t\t\t// In the event this subtree creates a new context for its children, restore\n\t\t\t// the previous context for its siblings\n\t\t\trendererState._context = prevContext;\n\t\t} catch (e) {\n\t\t\t// @TODO: assign a new VNode ID here? Or NaN?\n\t\t\t// newVNode._vnodeId = 0;\n\t\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t}\n\n\tif (options.diffed) options.diffed(internal);\n\n\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\tinternal.flags &= RESET_MODE;\n\n\t// Once we have successfully rendered the new VNode, copy it's ID over\n\tinternal._vnodeId = vnode._vnodeId;\n\n\tinternal._prevRef = internal.ref;\n\tinternal.ref = vnode.ref;\n}\n\n/**\n * Update an internal and its associated DOM element based on a new VNode\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').VNode} vnode A VNode with props to compare and apply\n */\nfunction patchElement(internal, vnode) {\n\tlet dom = /** @type {import('../internal').PreactElement} */ (internal._dom),\n\t\toldProps = internal.props,\n\t\tnewProps = (internal.props = vnode.props),\n\t\tisSvg = internal.flags & MODE_SVG,\n\t\ti,\n\t\tvalue,\n\t\ttmp,\n\t\tnewHtml,\n\t\toldHtml,\n\t\tnewChildren;\n\n\tfor (i in oldProps) {\n\t\tvalue = oldProps[i];\n\t\tif (i === 'children') {\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\toldHtml = value;\n\t\t} else if (!(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, value, isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tvalue = newProps[i];\n\t\tif (i === 'children') {\n\t\t\tnewChildren = value;\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\tnewHtml = value;\n\t\t} else if (\n\t\t\tvalue !== (tmp = oldProps[i]) ||\n\t\t\t((i === 'checked' || i === 'value') && value != null && value !== dom[i])\n\t\t) {\n\t\t\tsetProperty(dom, i, value, tmp, isSvg);\n\t\t}\n\t}\n\n\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\tif (newHtml) {\n\t\tvalue = newHtml.__html;\n\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\tif (!oldHtml || (value !== oldHtml.__html && value !== dom.innerHTML)) {\n\t\t\tdom.innerHTML = value;\n\t\t}\n\t\tinternal._children = null;\n\t} else {\n\t\tif (oldHtml) dom.innerHTML = '';\n\t\tconst prevParentDom = rendererState._parentDom;\n\t\trendererState._parentDom = dom;\n\t\tpatchChildren(\n\t\t\tinternal,\n\t\t\tnewChildren && Array.isArray(newChildren) ? newChildren : [newChildren],\n\t\t);\n\t\trendererState._parentDom = prevParentDom;\n\t}\n\n\tif (newProps.checked != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.checked;\n\t} else if (newProps.value != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.value;\n\t}\n}\n","import { commitRoot } from './diff/commit';\nimport options from './options';\nimport { createVNode, Fragment } from './create-element';\nimport { patch } from './diff/patch';\nimport { DIRTY_BIT, FORCE_UPDATE, MODE_UNMOUNTING } from './constants';\nimport { getParentContext, getParentDom } from './tree';\n\n/**\n * The render queue\n * @type {import('./internal').RendererState}\n */\nexport const rendererState = {\n\t_parentDom: null,\n\t_context: {},\n\t_commitQueue: []\n};\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = Object.assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(Object.assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tObject.assign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tconst internal = this._internal;\n\tif (update != null && internal) {\n\t\tif (callback) internal._commitCallbacks.push(callback.bind(this));\n\t\tinternal.rerender(internal);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tconst internal = this._internal;\n\tif (internal) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tinternal.flags |= FORCE_UPDATE;\n\t\tif (callback) internal._commitCallbacks.push(callback.bind(this));\n\t\tinternal.rerender(internal);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nfunction rerender(internal) {\n\tif (~internal.flags & MODE_UNMOUNTING && internal.flags & DIRTY_BIT) {\n\t\tconst vnode = createVNode(\n\t\t\tinternal.type,\n\t\t\tinternal.props,\n\t\t\tinternal.key, // @TODO we shouldn't need to actually pass these\n\t\t\tinternal.ref, // since the mode flag should bypass key/ref handling\n\t\t\t0\n\t\t);\n\n\t\trendererState._context = getParentContext(internal);\n\t\trendererState._commitQueue = [];\n\t\trendererState._parentDom = getParentDom(internal);\n\t\tpatch(internal, vnode);\n\t\tcommitRoot(internal);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Internal>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Enqueue a rerender of an internal\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nexport function enqueueRender(internal) {\n\tif (\n\t\t(!(internal.flags & DIRTY_BIT) &&\n\t\t\t(internal.flags |= DIRTY_BIT) &&\n\t\t\trerenderQueue.push(internal) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\twhile ((len = process._rerenderCount = rerenderQueue.length)) {\n\t\trerenderQueue.sort((a, b) => a._depth - b._depth);\n\t\twhile (len--) {\n\t\t\trerender(rerenderQueue.shift());\n\t\t}\n\t}\n}\nlet len = (process._rerenderCount = 0);\n","import { rendererState } from '../component';\nimport options from '../options';\n\n/**\n * @param {import('../internal').Internal} rootInternal\n */\nexport function commitRoot(rootInternal) {\n\tlet commitQueue = [].concat(rendererState._commitQueue);\n\trendererState._commitQueue = [];\n\n\tif (options._commit) options._commit(rootInternal, commitQueue);\n\n\tcommitQueue.some(internal => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the root variable here so the type changes\n\t\t\tcommitQueue = internal._commitCallbacks.length;\n\t\t\t// @ts-ignore See above ts-ignore comment\n\t\t\twhile (commitQueue--) {\n\t\t\t\tinternal._commitCallbacks.shift()();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t});\n}\n","import {\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { commitRoot } from './diff/commit';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { mount } from './diff/mount';\nimport { patch } from './diff/patch';\nimport { createInternal } from './tree';\nimport { rendererState } from './component';\n\n/**\n *\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * @returns {import('./internal').Root}\n */\nexport function createRoot(parentDom) {\n\tlet rootInternal,\n\t\tfirstChild,\n\t\tflags = 0;\n\n\tfunction render(vnode) {\n\t\tif (options._root) options._root(vnode, parentDom);\n\n\t\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\n\t\tfirstChild =\n\t\t\t/** @type {import('./internal').PreactElement} */ (parentDom.firstChild);\n\n\t\trendererState._context = {};\n\t\t// List of effects that need to be called after diffing:\n\t\trendererState._commitQueue = [];\n\t\trendererState._parentDom = parentDom;\n\n\t\tif (rootInternal) {\n\t\t\tpatch(rootInternal, vnode);\n\t\t} else {\n\t\t\trootInternal = createInternal(vnode, undefined);\n\n\t\t\t// Store the VDOM tree root on the DOM element in a (minified) property:\n\t\t\tparentDom._children = rootInternal;\n\n\t\t\t// Calling createRoot().render() on an Element with existing children triggers mutative hydrate mode:\n\t\t\tif (firstChild) {\n\t\t\t\tflags = flags || MODE_MUTATIVE_HYDRATE;\n\t\t\t}\n\t\t\t// If the parent of this tree is within an inline SVG, the tree should start off in SVG mode:\n\t\t\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\t\t\tflags |= MODE_SVG;\n\t\t\t}\n\t\t\trootInternal.flags |= flags;\n\n\t\t\trootInternal._context = {};\n\n\t\t\tmount(rootInternal, vnode, firstChild);\n\t\t}\n\n\t\t// Flush all queued effects\n\t\tcommitRoot(rootInternal);\n\t}\n\n\treturn {\n\t\thydrate(vnode) {\n\t\t\tflags |= MODE_HYDRATE;\n\t\t\trender(vnode);\n\t\t},\n\t\trender\n\t};\n}\n","import { createRoot } from './create-root';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n */\nexport function render(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.render(vnode);\n\tparentDom._root = root;\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.hydrate(vnode);\n\tparentDom._root = root;\n}\n","import { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = Object.assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\n\tif (children !== undefined) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\t0\n\t);\n}\n","import { createElement } from './create-element';\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\treturn props.children;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\t// Note: We can't use Fragment here because a component that returned a Portal\n\t// (e.g. `const App = () => createPortal(...)`) wouldn't work. Our diff\n\t// collapses Fragments without keys that are returned directly from components\n\t// into just an array and sets that as the children array of the component.\n\t//\n\t// We also can't use keyed Fragments here cuz it might lead to weird edge\n\t// cases when toggling between two sibling portals if we use a shared keyed or\n\t// lead to unnecessary re-mounts if trying to generate a new key on each call.\n\t//\n\t// So the simplest solution seems to be just to use an unique type for Portal\n\t// to skip the Fragment collapsing logic when diffing components\n\treturn createElement(Portal, { _parentDom: container }, vnode);\n}\n"],"names":["EMPTY_ARR","options","[object Object]","error","internal","TYPE_CLASS","flags","type","getDerivedStateFromError","setState","componentDidCatch","e","vnodeId","createElement","props","children","key","ref","i","normalizedProps","arguments","length","push","undefined","createVNode","original","vnode","constructor","__v","normalizeToVNode","childVNode","Array","isArray","Fragment","String","createRef","current","isValidElement","applyRef","value","setStyle","dom","style","setProperty","name","oldValue","isSvg","useCapture","o","replace","toLowerCase","slice","_listeners","addEventListener","eventProxyCapture","eventProxy","removeEventListener","setAttribute","removeAttribute","this","event","_isControlled","_prevValue","checked","renderFunctionComponent","newVNode","componentContext","c","renderResult","newProps","context","forceUpdate","rerender","bind","renderHook","counter","call","getChildContext","rendererState","Object","assign","renderClassComponent","isNew","oldProps","oldState","snapshot","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","render","getSnapshotBeforeUpdate","componentDidUpdate","createInternal","parentInternal","MODE_HYDRATE","prototype","_prevRef","data","__h","enqueueRender","__k","__","__e","__c","__b","shouldSearchComponent","getParentDom","getDomSibling","childIndex","indexOf","getChildDom","child","TYPE_TEXT","childDom","getParentContext","parent","mount","startDom","nextDomSibling","prevStartDom","prevParentDom","prevContext","tmp","contextType","provider","add","mountChildren","_commitQueue","mountElement","diffed","then","nextSibling","nodeType","isFullRender","localName","document","createTextNode","createElementNS","is","attributes","newHtml","newValue","newChildren","onInput","onChange","innerHTML","firstChild","childInternal","newDom","mountedNextChild","internalChildren","insertBefore","remove","nextContextId","providers","Set","unsubscribeFromContext","delete","forEach","p","createContext","defaultValue","contextId","Consumer","contextValue","Provider","ctx","unmount","skipRemove","r","componentWillUnmount","patchChildren","oldChildren","oldChildrenLength","remainingOldChildren","skew","skewedIndex","matchingIndex","findMatchingIndex","mountingChild","patch","go","insertComponentDom","oldRef","match","x","y","oldChild","parentDom","toChildArray","out","patchElement","MODE_PENDING_ERROR","oldHtml","__P","Component","commitRoot","update","callback","s","prevDebounce","rerenderQueue","defer","Promise","resolve","process","debounceRendering","len","sort","a","b","shift","rootInternal","commitQueue","concat","some","createRoot","ownerSVGElement","hydrate","root","cloneElement","Portal","createPortal","container"],"mappings":"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"}