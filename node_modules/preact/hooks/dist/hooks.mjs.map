{"version":3,"file":"hooks.mjs","sources":["../../src/tree.js","../src/index.js","../../src/component.js","../../src/constants.js"],"sourcesContent":["import options from './options';\nimport {\n\tTYPE_FUNCTION,\n\tTYPE_ELEMENT,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tTYPE_ROOT,\n\tINHERITED_MODES,\n\tTYPE_COMPONENT,\n\tTYPE_DOM,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { enqueueRender } from './component';\n\n/**\n * Create an internal tree node\n * @param {import('./internal').VNode | string} vnode\n * @param {import('./internal').Internal} [parentInternal]\n * @returns {import('./internal').Internal}\n */\nexport function createInternal(vnode, parentInternal) {\n\tlet type = null,\n\t\tprops,\n\t\tkey,\n\t\tref;\n\n\t/** @type {number} */\n\tlet flags = parentInternal ? parentInternal.flags & INHERITED_MODES : 0;\n\n\t// Text VNodes/Internals have an ID of 0 that is never used:\n\tlet vnodeId = 0;\n\n\tif (typeof vnode === 'string') {\n\t\t// type = null;\n\t\tflags |= TYPE_TEXT;\n\t\tprops = vnode;\n\t}\n\t// Prevent JSON injection by rendering injected objects as empty Text nodes\n\telse if (vnode.constructor !== UNDEFINED) {\n\t\tflags |= TYPE_TEXT;\n\t\tprops = '';\n\t} else {\n\t\ttype = vnode.type;\n\t\tprops = vnode.props;\n\t\tkey = vnode.key;\n\t\tref = vnode.ref;\n\t\tvnodeId = vnode._vnodeId;\n\n\t\t// @TODO re-enable this when we stop removing key+ref from VNode props\n\t\t// if (props) {\n\t\t// \tif ((key = props.key) != null) {\n\t\t// \t\tprops.key = UNDEFINED;\n\t\t// \t}\n\t\t// \tif (typeof type !== 'function' && (ref = props.ref) != null) {\n\t\t// \t\tprops.ref = UNDEFINED;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tprops = {};\n\t\t// }\n\n\t\t// flags = typeof type === 'function' ? COMPONENT_NODE : ELEMENT_NODE;\n\t\tflags |=\n\t\t\ttypeof type === 'function'\n\t\t\t\t? type.prototype && type.prototype.render\n\t\t\t\t\t? TYPE_CLASS\n\t\t\t\t\t: props._parentDom\n\t\t\t\t\t? TYPE_ROOT\n\t\t\t\t\t: TYPE_FUNCTION\n\t\t\t\t: TYPE_ELEMENT;\n\n\t\tif (flags & TYPE_ELEMENT && type === 'svg') {\n\t\t\tflags |= MODE_SVG;\n\t\t} else if (\n\t\t\tparentInternal &&\n\t\t\tparentInternal.flags & MODE_SVG &&\n\t\t\tparentInternal.type === 'foreignObject'\n\t\t) {\n\t\t\tflags &= ~MODE_SVG;\n\t\t}\n\t}\n\n\t/** @type {import('./internal').Internal} */\n\tconst internal = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_prevRef: null,\n\t\tdata: flags & TYPE_COMPONENT ? {} : null,\n\t\t_commitCallbacks: flags & TYPE_COMPONENT ? [] : null,\n\t\trerender: enqueueRender,\n\t\tflags,\n\t\t_children: null,\n\t\t_parent: parentInternal,\n\t\t_vnodeId: vnodeId,\n\t\t_dom: null,\n\t\t_component: null,\n\t\t_context: null,\n\t\t_depth: parentInternal ? parentInternal._depth + 1 : 0\n\t};\n\n\tif (options._internal) options._internal(internal, vnode);\n\n\treturn internal;\n}\n\nconst shouldSearchComponent = internal =>\n\tinternal.flags & TYPE_COMPONENT &&\n\t(!(internal.flags & TYPE_ROOT) ||\n\t\tinternal.props._parentDom == getParentDom(internal._parent));\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number | null} [childIndex]\n * @returns {import('./internal').PreactNode}\n */\nexport function getDomSibling(internal, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn getDomSibling(\n\t\t\tinternal._parent,\n\t\t\tinternal._parent._children.indexOf(internal) + 1\n\t\t);\n\t}\n\n\tlet childDom = getChildDom(internal, childIndex);\n\tif (childDom) {\n\t\treturn childDom;\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children. We\n\t// must resume from this vnode's sibling (in it's parent _children array).\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search). Note, the top of the tree has _parent == null so avoiding that\n\t// here.\n\treturn internal._parent && shouldSearchComponent(internal)\n\t\t? getDomSibling(internal)\n\t\t: null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number} [i]\n * @returns {import('./internal').PreactElement}\n */\nexport function getChildDom(internal, i) {\n\tif (internal._children == null) {\n\t\treturn null;\n\t}\n\n\tfor (i = i || 0; i < internal._children.length; i++) {\n\t\tlet child = internal._children[i];\n\t\tif (child != null) {\n\t\t\tif (child.flags & TYPE_DOM) {\n\t\t\t\treturn child._dom;\n\t\t\t}\n\n\t\t\tif (shouldSearchComponent(child)) {\n\t\t\t\tlet childDom = getChildDom(child);\n\t\t\t\tif (childDom) {\n\t\t\t\t\treturn childDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n/**\n * @param {import('./internal').Internal} internal\n * @returns {any}\n */\nexport function getParentContext(internal) {\n\t// @TODO: compare performance of recursion here (it's 11b smaller, but may be slower for deep trees)\n\treturn internal._context || getParentContext(internal._parent);\n\n\t// while ((internal = internal._parent)) {\n\t// \tlet context = internal._context;\n\t// \tif (context != null) return context;\n\t// }\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @returns {import('./internal').PreactElement}\n */\nexport function getParentDom(internal) {\n\tlet parent = internal;\n\n\t// if this is a Root internal, return its parent DOM:\n\tif (parent.flags & TYPE_ROOT) {\n\t\treturn parent.props._parentDom;\n\t}\n\n\t// walk up the tree to find the nearest DOM or Root Internal:\n\twhile ((parent = parent._parent)) {\n\t\tif (parent.flags & TYPE_ROOT) {\n\t\t\treturn parent.props._parentDom;\n\t\t} else if (parent.flags & TYPE_ELEMENT) {\n\t\t\treturn parent._dom;\n\t\t}\n\t}\n}\n","import { options } from 'preact';\nimport { getParentContext } from '../../src/tree';\nimport { MODE_UNMOUNTING } from '../../src/constants';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Internal} */\nlet currentInternal;\n\n/** @type {import('./internal').Internal} */\nlet previousInternal;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {number} */\nlet currentIdCounter = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._diff = (internal, vnode) => {\n\tcurrentInternal = null;\n\tif (oldBeforeDiff) oldBeforeDiff(internal, vnode);\n};\n\noptions._render = internal => {\n\tif (oldBeforeRender) oldBeforeRender(internal);\n\n\tcurrentInternal = internal;\n\tcurrentIndex = 0;\n\n\tif (currentInternal.data && currentInternal.data.__hooks) {\n\t\tif (previousInternal === currentInternal) {\n\t\t\tcurrentInternal.data.__hooks._pendingEffects = [];\n\t\t\tcurrentInternal._commitCallbacks = [];\n\t\t\tcurrentInternal.data.__hooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._pendingArgs) hookItem._pendingArgs = undefined;\n\t\t\t\tif (hookItem._pendingValue) hookItem._pendingValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\tif (internal.data && internal.data.__hooks) {\n\t\t\t\tinternal.data &&\n\t\t\t\t\tinternal.data.__hooks._list.forEach(hookItem => {\n\t\t\t\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t\t\t\t\thookItem._pendingArgs = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hookItem._pendingValue) {\n\t\t\t\t\t\t\thookItem._value = hookItem._pendingValue;\n\t\t\t\t\t\t\thookItem._pendingValue = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t\tcurrentInternal.data.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcurrentInternal.data.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcurrentInternal.data.__hooks._pendingEffects = [];\n\t\t}\n\t}\n\tpreviousInternal = internal;\n};\n\noptions.diffed = internal => {\n\tif (oldAfterDiff) oldAfterDiff(internal);\n\n\tpreviousInternal = undefined;\n\tif (\n\t\tinternal.data &&\n\t\tinternal.data.__hooks &&\n\t\tinternal.data.__hooks._pendingEffects.length\n\t) {\n\t\tafterPaint(afterPaintEffects.push(internal));\n\t}\n};\n\noptions._commit = (internal, commitQueue) => {\n\tcommitQueue.some(internal => {\n\t\ttry {\n\t\t\tif (internal.data && internal.data.__hooks) {\n\t\t\t\tinternal.data &&\n\t\t\t\t\tinternal.data.__hooks._list.forEach(hookItem => {\n\t\t\t\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t\t\t\t\thookItem._pendingArgs = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hookItem._pendingValue) {\n\t\t\t\t\t\t\thookItem._value = hookItem._pendingValue;\n\t\t\t\t\t\t\thookItem._pendingValue = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t\tinternal._commitCallbacks.forEach(invokeCleanup);\n\t\t\tinternal._commitCallbacks = internal._commitCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(i => {\n\t\t\t\tif (i._commitCallbacks) i._commitCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(internal, commitQueue);\n};\n\noptions.unmount = internal => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(internal);\n\n\tif (internal.data && internal.data.__hooks) {\n\t\tlet hasErrored;\n\t\tinternal.data.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tif (hasErrored) options._catchError(hasErrored, internal);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentInternal, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentInternal.data.__hooks ||\n\t\t(currentInternal.data.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} [initialState]\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._internal) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._internal.rerender(hookState._internal);\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._internal = currentInternal;\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentInternal.data.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tif (currentInternal._commitCallbacks == null) {\n\t\t\tcurrentInternal._commitCallbacks = [];\n\t\t}\n\t\tcurrentInternal._commitCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useReducer(invokeEffect, { current: initialValue })[0];\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._pendingValue = factory();\n\t\tstate._pendingArgs = args;\n\t\tstate._factory = factory;\n\t\treturn state._pendingValue;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = getParentContext(currentInternal)[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider._subs.add(currentInternal);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nconst oldCatchError = options._catchError;\n// TODO: this double traverses now in combination with the root _catchError\n// however when we split Component up this shouldn't be needed\n// there can be a better solution to this if we just do a single iteration\n// as a combination of suspsense + hooks + component (compat) would be 3 tree-iterations\noptions._catchError = function(error, internal) {\n\t/** @type {import('./internal').Component} */\n\tlet handler = internal;\n\tfor (; (handler = handler._parent); ) {\n\t\tif (handler.data && handler.data._catchError) {\n\t\t\treturn handler.data._catchError(error, internal);\n\t\t}\n\t}\n\n\toldCatchError(error, internal);\n};\n\n/**\n * @param {(error: any) => void} cb\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\n\tif (!currentInternal.data._catchError) {\n\t\tcurrentInternal.data._catchError = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\nexport function useId() {\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._id) {\n\t\tcurrentIdCounter++;\n\n\t\tstate._id =\n\t\t\t'_P' +\n\t\t\t(currentInternal._parent._children.indexOf(currentInternal) +\n\t\t\t\tcurrentInternal._depth +\n\t\t\t\tcurrentIdCounter);\n\t}\n\treturn state._id;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet internal;\n\twhile ((internal = afterPaintEffects.shift())) {\n\t\tif (~internal.flags & MODE_UNMOUNTING) {\n\t\t\ttry {\n\t\t\t\tinternal.data.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tinternal.data.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tinternal.data.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tinternal.data.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, internal);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentInternal away.\n\tconst internal = currentInternal;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\tcurrentInternal = internal;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentInternal away.\n\tconst internal = currentInternal;\n\thook._cleanup = hook._value();\n\tcurrentInternal = internal;\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n","import { commitRoot } from './diff/commit';\nimport options from './options';\nimport { createVNode, Fragment } from './create-element';\nimport { patch } from './diff/patch';\nimport { DIRTY_BIT, FORCE_UPDATE, MODE_UNMOUNTING } from './constants';\nimport { getParentContext, getParentDom } from './tree';\n\n/**\n * The render queue\n * @type {import('./internal').RendererState}\n */\nexport const rendererState = {\n\t_parentDom: null,\n\t_context: {},\n\t_commitQueue: []\n};\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = Object.assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(Object.assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tObject.assign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tconst internal = this._internal;\n\tif (update != null && internal) {\n\t\tif (callback) internal._commitCallbacks.push(callback.bind(this));\n\t\tinternal.rerender(internal);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tconst internal = this._internal;\n\tif (internal) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tinternal.flags |= FORCE_UPDATE;\n\t\tif (callback) internal._commitCallbacks.push(callback.bind(this));\n\t\tinternal.rerender(internal);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nfunction rerender(internal) {\n\tif (~internal.flags & MODE_UNMOUNTING && internal.flags & DIRTY_BIT) {\n\t\tconst vnode = createVNode(\n\t\t\tinternal.type,\n\t\t\tinternal.props,\n\t\t\tinternal.key, // @TODO we shouldn't need to actually pass these\n\t\t\tinternal.ref, // since the mode flag should bypass key/ref handling\n\t\t\t0\n\t\t);\n\n\t\trendererState._context = getParentContext(internal);\n\t\trendererState._commitQueue = [];\n\t\trendererState._parentDom = getParentDom(internal);\n\t\tpatch(internal, vnode);\n\t\tcommitRoot(internal);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Internal>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Enqueue a rerender of an internal\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nexport function enqueueRender(internal) {\n\tif (\n\t\t(!(internal.flags & DIRTY_BIT) &&\n\t\t\t(internal.flags |= DIRTY_BIT) &&\n\t\t\trerenderQueue.push(internal) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\twhile ((len = process._rerenderCount = rerenderQueue.length)) {\n\t\trerenderQueue.sort((a, b) => a._depth - b._depth);\n\t\twhile (len--) {\n\t\t\trerender(rerenderQueue.shift());\n\t\t}\n\t}\n}\nlet len = (process._rerenderCount = 0);\n","// Internal.flags bitfield constants\nexport const TYPE_TEXT = 1 << 0;\nexport const TYPE_ELEMENT = 1 << 1;\nexport const TYPE_CLASS = 1 << 2;\nexport const TYPE_FUNCTION = 1 << 3;\n/** Signals this internal has a _parentDom prop that should change the parent\n * DOM node of it's children */\nexport const TYPE_ROOT = 1 << 4;\n\n/** Any type of internal representing DOM */\nexport const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;\n/** Any type of component */\nexport const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;\n\n// Modes of rendering\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Top level render unspecified behaviour (old replaceNode parameter to render) */\nexport const MODE_MUTATIVE_HYDRATE = 1 << 6;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Signifies this VNode errored on the previous render */\nexport const MODE_ERRORED = 1 << 8;\n/** Signifies an error has been thrown and this component will be attempting to\n * handle & rerender the error on next render. In other words, on the next\n * render of this component, unset this mode and set the MODE_RERENDERING_ERROR.\n * This flag is distinct from MODE_RERENDERING_ERROR so that a component can\n * catch multiple errors thrown by its children in one render pass (see test\n * \"should handle double child throws\").\n */\nexport const MODE_PENDING_ERROR = 1 << 9;\n/** Signifies this Internal is attempting to \"handle\" an error and is\n * rerendering. This mode tracks that a component's last rerender was trying to\n * handle an error. As such, if another error is thrown while a component has\n * this flag set, it should not handle the newly thrown error since it failed to\n * successfully rerender the original error. This prevents error handling\n * infinite render loops */\nexport const MODE_RERENDERING_ERROR = 1 << 10;\n/** Signals this internal has been unmounted */\nexport const MODE_UNMOUNTING = 1 << 11;\n/** This Internal is rendered in an SVG tree */\nexport const MODE_SVG = 1 << 12;\n\n/** Signifies that bailout checks will be bypassed */\nexport const FORCE_UPDATE = 1 << 13;\n/** Signifies that a node needs to be updated */\nexport const DIRTY_BIT = 1 << 14;\n/** Signals the component can skip children due to a non-update */\nexport const SKIP_CHILDREN = 1 << 15;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(\n\tMODE_HYDRATE |\n\tMODE_MUTATIVE_HYDRATE |\n\tMODE_SUSPENDED |\n\tMODE_ERRORED |\n\tMODE_RERENDERING_ERROR |\n\tFORCE_UPDATE |\n\tSKIP_CHILDREN\n);\n\n/** Modes a child internal inherits from their parent */\nexport const INHERITED_MODES = MODE_HYDRATE | MODE_MUTATIVE_HYDRATE | MODE_SVG;\n\nexport const EMPTY_ARR = [];\nexport const UNDEFINED = undefined;\n"],"names":["getParentContext","internal","currentIndex","currentInternal","previousInternal","Promise","prototype","then","bind","resolve","prevRaf","currentHook","currentIdCounter","afterPaintEffects","oldBeforeDiff","options","oldBeforeRender","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","data","__","__h","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","rerender","useEffect","callback","args","state","argsChanged","_pendingArgs","useLayoutEffect","useRef","initialValue","invokeEffect","current","useImperativeHandle","ref","createHandle","concat","useMemo","factory","_pendingValue","useCallback","useContext","context","provider","add","props","value","useDebugValue","formatter","vnode","forEach","hookItem","invokeCleanup","requestAnimationFrame","afterNextFrame","flushAfterPaintEffects","commitQueue","some","filter","cb","e","i","hasErrored","s","oldCatchError","useErrorBoundary","errState","err","useId","indexOf","shift","flags","error","handler","HAS_RAF","done","clearTimeout","timeout","cancelAnimationFrame","raf","setTimeout","hook","cleanup","oldArgs","newArgs","arg","f"],"mappings":"0CA8KgBA,EAAiBC,GAEhC,OAAOA,KAAqBD,EAAiBC,MC3K9C,IAAIC,EAGAC,EAGAC,EC4HUC,QAAQC,UAAUC,KAAKC,KAAKH,QAAQI,WDzHlD,IAeIC,EAfAC,EAAc,EAGdC,EAAmB,EAGnBC,EAAoB,GAEpBC,EAAgBC,MAChBC,EAAkBD,MAClBE,EAAeF,EAAQG,OACvBC,EAAYJ,MACZK,EAAmBL,EAAQM,QAiH/B,SAASC,EAAaC,EAAOC,GACxBT,OACHA,MAAcZ,EAAiBoB,EAAOZ,GAAea,GAEtDb,EAAc,EAOd,MAAMc,EACLtB,EAAgBuB,WACfvB,EAAgBuB,SAAe,CAC/BC,GAAO,GACPC,IAAiB,KAMnB,OAHIL,GAASE,KAAYI,QACxBJ,KAAYK,KAAK,IAEXL,KAAYF,YAMJQ,EAASC,GAExB,OADArB,EAAc,EACPsB,EAAWC,EAAgBF,YASnBC,EAAWE,EAASH,EAAcI,GAEjD,MAAMC,EAAYf,EAAapB,IAAgB,GAkB/C,OAjBAmC,EAAUC,EAAWH,EAChBE,QACJA,KAAmB,CACjBD,EAAiDA,EAAKJ,GAA/CE,OAAeK,EAAWP,GAElCQ,IACC,MAAMC,EAAYJ,EAAUC,EAASD,KAAiB,GAAIG,GACtDH,KAAiB,KAAOI,IAC3BJ,KAAmB,CAACI,EAAWJ,KAAiB,IAChDA,MAAoBK,SAASL,UAKhCA,MAAsBlC,GAGhBkC,cAOQM,EAAUC,EAAUC,GAEnC,MAAMC,EAAQxB,EAAapB,IAAgB,IACtCa,OAAwBgC,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,EAAME,EAAeH,EAErB1C,EAAgBuB,aAA6BI,KAAKgB,aAQpCG,EAAgBL,EAAUC,GAEzC,MAAMC,EAAQxB,EAAapB,IAAgB,IACtCa,OAAwBgC,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,EAAME,EAAeH,EAEmB,MAApC1C,QACHA,MAAmC,IAEpCA,MAAiC2B,KAAKgB,aAIxBI,EAAOC,GAEtB,OADAxC,EAAc,EACPsB,EAAWmB,EAAc,CAAEC,QAASF,IAAgB,YAQ5CG,EAAoBC,EAAKC,EAAcX,GACtDlC,EAAc,EACdsC,EACC,IACmB,mBAAPM,GACVA,EAAIC,KACG,IAAMD,EAAI,OACPA,GACVA,EAAIF,QAAUG,IACP,IAAOD,EAAIF,QAAU,aAGtB,MAARR,EAAeA,EAAOA,EAAKY,OAAOF,aAQpBG,EAAQC,EAASd,GAEhC,MAAMC,EAAQxB,EAAapB,IAAgB,GAC3C,OAAI6C,EAAYD,MAAaD,IAC5BC,EAAMc,EAAgBD,IACtBb,EAAME,EAAeH,EACrBC,MAAiBa,EACVb,EAAMc,GAGPd,cAOQe,EAAYjB,EAAUC,GAErC,OADAlC,EAAc,EACP+C,EAAQ,IAAMd,EAAUC,YAMhBiB,EAAWC,GAC1B,MAAMC,EAAWhE,EAAiBG,GAAiB4D,OAK7CjB,EAAQxB,EAAapB,IAAgB,GAK3C,OADA4C,IAAiBiB,EACZC,GAEe,MAAhBlB,OACHA,MAAe,EACfkB,IAAeC,IAAI9D,IAEb6D,EAASE,MAAMC,OANAJ,cAaPK,EAAcD,EAAOE,GAChCtD,EAAQqD,eACXrD,EAAQqD,cAAcC,EAAYA,EAAUF,GAASA,GA3RvDpD,MAAgB,CAACd,EAAUqE,KAC1BnE,EAAkB,KACdW,GAAeA,EAAcb,EAAUqE,IAG5CvD,MAAkBd,IACbe,GAAiBA,EAAgBf,GAErCE,EAAkBF,EAClBC,EAAe,EAEXC,EAAgBuB,MAAQvB,EAAgBuB,WACvCtB,IAAqBD,GACxBA,EAAgBuB,aAA+B,GAC/CvB,MAAmC,GACnCA,EAAgBuB,YAAmB6C,QAAQC,IACtCA,EAASxB,IAAcwB,EAASxB,OAAeT,GAC/CiC,EAASZ,IAAeY,EAASZ,OAAgBrB,OAGlDtC,EAASyB,MAAQzB,EAASyB,UAC7BzB,EAASyB,MACRzB,EAASyB,YAAmB6C,QAAQC,IAC/BA,EAASxB,IACZwB,MAAiBA,EAASxB,EAC1BwB,EAASxB,OAAeT,GAErBiC,EAASZ,IACZY,KAAkBA,EAASZ,EAC3BY,EAASZ,OAAgBrB,KAI7BpC,EAAgBuB,aAA6B6C,QAAQE,GACrDtE,EAAgBuB,aAA6B6C,QAAQnB,GACrDjD,EAAgBuB,aAA+B,KAGjDtB,EAAmBH,GAGpBc,EAAQG,OAASjB,IACZgB,GAAcA,EAAahB,GAE/BG,OAAmBmC,EAElBtC,EAASyB,MACTzB,EAASyB,UACTzB,EAASyB,aAA6BG,SA0VhB,IAxVXhB,EAAkBiB,KAAK7B,IAwVPS,IAAYK,EAAQ2D,wBAC/ChE,EAAUK,EAAQ2D,uBACjBhE,GAAWiE,GAAgBC,MAtV9B7D,MAAkB,CAACd,EAAU4E,KAC5BA,EAAYC,KAAK7E,IAChB,IACKA,EAASyB,MAAQzB,EAASyB,UAC7BzB,EAASyB,MACRzB,EAASyB,YAAmB6C,QAAQC,IAC/BA,EAASxB,IACZwB,MAAiBA,EAASxB,EAC1BwB,EAASxB,OAAeT,GAErBiC,EAASZ,IACZY,KAAkBA,EAASZ,EAC3BY,EAASZ,OAAgBrB,KAI7BtC,MAA0BsE,QAAQE,GAClCxE,MAA4BA,MAA0B8E,OAAOC,IAC5DA,MAAY5B,EAAa4B,IAEzB,MAAOC,GACRJ,EAAYC,KAAKI,IACZA,QAAoBA,MAAqB,MAE9CL,EAAc,GACd9D,MAAoBkE,EAAGhF,MAIrBkB,GAAWA,EAAUlB,EAAU4E,IAGpC9D,EAAQM,QAAUpB,IAGjB,GAFImB,GAAkBA,EAAiBnB,GAEnCA,EAASyB,MAAQzB,EAASyB,SAAc,CAC3C,IAAIyD,EACJlF,EAASyB,YAAmB6C,QAAQa,IACnC,IACCX,EAAcW,GACb,MAAOH,GACRE,EAAaF,KAGXE,GAAYpE,MAAoBoE,EAAYlF,KA6LlD,MAAMoF,EAAgBtE,eAoBNuE,EAAiBN,GAEhC,MAAMlC,EAAQxB,EAAapB,IAAgB,IACrCqF,EAAWxD,IASjB,OARAe,KAAekC,EAEV7E,EAAgBuB,WACpBvB,EAAgBuB,SAAmB8D,IAC9B1C,MAAcA,KAAa0C,GAC/BD,EAAS,GAAGC,KAGP,CACND,EAAS,GACT,KACCA,EAAS,QAAGhD,cAKCkD,IACf,MAAM3C,EAAQxB,EAAapB,IAAgB,IAU3C,OATK4C,QACJlC,IAEAkC,MACC,MACC3C,SAAkCuF,QAAQvF,GAC1CA,MACAS,IAEIkC,MAMR,SAAS8B,IACR,IAAI3E,EACJ,KAAQA,EAAWY,EAAkB8E,SACpC,GEnV6B,MFmVxB1F,EAAS2F,MACb,IACC3F,EAASyB,aAA6B6C,QAAQE,GAC9CxE,EAASyB,aAA6B6C,QAAQnB,GAC9CnD,EAASyB,aAA+B,GACvC,MAAOuD,GACRhF,EAASyB,aAA+B,GACxCX,MAAoBkE,EAAGhF,IA9D3Bc,MAAsB,SAAS8E,EAAO5F,GAErC,IAAI6F,EAAU7F,EACd,KAAQ6F,EAAUA,MACjB,GAAIA,EAAQpE,MAAQoE,EAAQpE,SAC3B,OAAOoE,EAAQpE,SAAiBmE,EAAO5F,GAIzCoF,EAAcQ,EAAO5F,IA2DtB,IAAI8F,EAA0C,mBAAzBrB,sBAYrB,SAASC,EAAe/B,GACvB,MAAMoD,EAAO,KACZC,aAAaC,GACTH,GAASI,qBAAqBC,GAClCC,WAAWzD,IAENsD,EAAUG,WAAWL,EA7XR,KA+XnB,IAAII,EACAL,IACHK,EAAM1B,sBAAsBsB,IAqB9B,SAASvB,EAAc6B,GAGtB,MAAMrG,EAAWE,EACjB,IAAIoG,EAAUD,MACQ,mBAAXC,IACVD,WAAgB/D,EAChBgE,KAEDpG,EAAkBF,EAOnB,SAASmD,EAAakD,GAGrB,MAAMrG,EAAWE,EACjBmG,MAAgBA,OAChBnG,EAAkBF,EAOnB,SAAS8C,EAAYyD,EAASC,GAC7B,OACED,GACDA,EAAQ3E,SAAW4E,EAAQ5E,QAC3B4E,EAAQ3B,KAAK,CAAC4B,EAAKnF,IAAUmF,IAAQF,EAAQjF,IAI/C,SAASW,EAAewE,EAAKC,GAC5B,MAAmB,mBAALA,EAAkBA,EAAED,GAAOC"}